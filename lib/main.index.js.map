{"version":3,"sources":["webpack://voltorbFlip/./src/Game/Game.js","webpack://voltorbFlip/./src/Grid/Cell.js","webpack://voltorbFlip/./src/Grid/Grid.js","webpack://voltorbFlip/./src/Grid/Memo.js","webpack://voltorbFlip/./src/index.js","webpack://voltorbFlip/external {\"commonjs\":\"lodash\",\"commonjs2\":\"lodash\",\"amd\":\"lodash\",\"root\":\"_\"}"],"names":["Game","startingLevel","width","height","maximalCoefficient","maxLevel","score","Grid","level","grid","playing","Error","nextLevel","won","lost","nbUncoveredGoodCells","Cell","mine","value","Memo","mines","Math","floor","sqrt","minimumCoefficients","_generateGrid","i","push","normalCoeffs","_nbNormalCells","total","normalCoeffsLength","length","index","noNewCoeffs","currentCoeff","possibleEvolution","_","random","evolution","map","shuffle","line","column","slice","filter","_getGroupIndications","getLine","getColumn","group","reduce","coefficients","_nbCells","some","covered","every","acc","elt","interrupted","Set","clear","has","numValue","Number","isNaN","isSafeInteger","add","delete","sort","a","b"],"mappings":"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","file":"main.index.js","sourcesContent":["import Grid from '../Grid/Grid.js';\r\n\r\nexport default class Game {\r\n  /**\r\n   * Score of the game.\r\n   * @type {number}\r\n   */\r\n  #score = 0;\r\n\r\n  /**\r\n   * Level of the game.\r\n   * @type {number}\r\n   */\r\n  #level = 1;\r\n\r\n  /**\r\n   * Max level of the game.\r\n   * @type {number}\r\n   */\r\n  #maxLevel = 8;\r\n\r\n  /**\r\n   * Current grid.\r\n   * @type {Grid}\r\n   */\r\n  #grid;\r\n\r\n  /**\r\n   * Maximal coefficient of each cell.\r\n   * @type {number}\r\n   */\r\n  #maximalCoefficient = 3;\r\n\r\n  /**\r\n   * Width of each grid of the game.\r\n   * @type {number}\r\n   */\r\n  #width = 5;\r\n\r\n  /**\r\n   * Height of each grid of the game.\r\n   * @type {number}\r\n   */\r\n  #height = 5;\r\n\r\n  /**\r\n   * @param {number} [startingLevel=1]\r\n   * @param {number} [width=5]\r\n   * @param {number} [height=5]\r\n   * @param {number} [maximalCoefficient=3]\r\n   * @param {number} [maxLevel=8]\r\n   * @param {number} [score=0] Default score for the game.\r\n   */\r\n  constructor({\r\n    startingLevel = 1,\r\n    width = 5,\r\n    height = 5,\r\n    maximalCoefficient = 3,\r\n    maxLevel = 8,\r\n    score = 0,\r\n  } = {}) {\r\n    this.#level = startingLevel;\r\n    this.#score = score;\r\n    this.#width = width;\r\n    this.#height = height;\r\n    this.#maximalCoefficient = maximalCoefficient;\r\n    this.#maxLevel = maxLevel;\r\n    this.#grid = new Grid({\r\n      width,\r\n      height,\r\n      level: this.#level,\r\n      maximalCoefficient,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Level of the game.\r\n   * @returns {number}\r\n   */\r\n  get level() {\r\n    return this.#level;\r\n  }\r\n\r\n  /**\r\n   * Total score of the game.\r\n   * @returns {number}\r\n   */\r\n  get score() {\r\n    return this.#score;\r\n  }\r\n\r\n  /**\r\n   * Current grid.\r\n   * @returns {Grid}\r\n   */\r\n  get grid() {\r\n    return this.#grid;\r\n  }\r\n\r\n  /**\r\n   * Level of the next grid.\r\n   * @returns {number}\r\n   */\r\n  get nextLevel() {\r\n    return this.grid.won ?\r\n      (this.#level >= this.#maxLevel ? this.#maxLevel : this.#level + 1) :\r\n      (this.grid.lost ?\r\n        (this.grid.nbUncoveredGoodCells >= this.#level ?\r\n          (this.#level) :\r\n            (this.grid.nbUncoveredGoodCells >= 1) ? this.grid.nbUncoveredGoodCells : 1) :\r\n        (this.#level));\r\n  }\r\n\r\n  /**\r\n   * Launch next level and save the score. The previous grid should **be finished**\r\n   * @return {Grid} The new grid.\r\n   * @throws {Error} If the grid hasn't ended.\r\n   */\r\n  gotoNextLevel() {\r\n    if (this.grid.playing) {\r\n      throw new Error('Please finish the current grid before going to another.');\r\n    }\r\n    const {grid} = this;\r\n    this.#score += grid.score;\r\n    this.#grid = new Grid({\r\n      width: this.#width,\r\n      height: this.#height,\r\n      level: this.nextLevel,\r\n      maximalCoefficient: this.#maximalCoefficient,\r\n    });\r\n\r\n    return this.#grid;\r\n  }\r\n\r\n  /**\r\n   * Reset the score to 0.\r\n   * @return {number} The previous score.\r\n   */\r\n  resetScore() {\r\n    const score = this.#score;\r\n    this.#score = 0;\r\n    return score;\r\n  }\r\n}\r\n","import Memo from './Memo.js';\r\n\r\nexport default class Cell {\r\n  /**\r\n   * If the cell contains a mine.\r\n   * @type {boolean}\r\n   */\r\n  #mine;\r\n\r\n  /**\r\n   * The value of the cell.\r\n   * @type {number}\r\n   */\r\n  #value;\r\n\r\n  /**\r\n   * If the cell is covered.\r\n   * @type {boolean}\r\n   */\r\n  #covered = true;\r\n\r\n  /**\r\n   * Memo on the case.\r\n   * @type {Memo}\r\n   */\r\n  #memo = new Memo();\r\n\r\n  /**\r\n   * @param {boolean} [mine=false] If the cell contains a mine.\r\n   * @param {number} [value=1] The value of the cell if it's not a mine.\r\n   * @param {Grid} [grid=null] The grid to which belongs this cell.\r\n   */\r\n  constructor({\r\n    mine = false,\r\n    value = mine ? 0 : 1,\r\n  } = {}) {\r\n    this.#mine = mine;\r\n    this.#value = value;\r\n  }\r\n\r\n  /**\r\n   * If the cell contains a mine.\r\n   * @returns {boolean}\r\n   */\r\n  get mine() {\r\n    return this.#mine;\r\n  }\r\n\r\n  /**\r\n   * The value of the cell (0 if there is a mine).\r\n   * @returns {number}\r\n   */\r\n  get value() {\r\n    return this.#mine ? 0 : this.#value;\r\n  }\r\n\r\n  /**\r\n   * If the cell is covered\r\n   * @returns {boolean}\r\n   */\r\n  get covered() {\r\n    return this.#covered;\r\n  }\r\n\r\n  /**\r\n   * The memo of the cell.\r\n   * @returns {Memo}\r\n   */\r\n  get memo() {\r\n    return this.#memo;\r\n  }\r\n\r\n  /**\r\n   * Uncovers the cell.\r\n   * @returns {number} The actual value of the uncovered cell. 0 If it's a mine.\r\n   */\r\n  uncover() {\r\n    this.#covered = true;\r\n    return this.value;\r\n  }\r\n};\r\n","import _ from 'lodash';\r\n\r\n/**\r\n * @typedef {Object} Indication Indication for row or column\r\n * @property {number} mines Number of mines in the group.\r\n * @property {number} coefficients Sum of coefficients in the group.\r\n */\r\n\r\nexport default class Grid {\r\n  /**\r\n   * Width of the grid.\r\n   * @type {number}\r\n   */\r\n  #width;\r\n\r\n  /**\r\n   * Height of the grid.\r\n   * @type {number}\r\n   */\r\n  #height;\r\n\r\n  /**\r\n   * Number of mines in the grid.\r\n   * @type {number}\r\n   */\r\n  #mines;\r\n\r\n  /**\r\n   * Minimal sum of coefficients generated.\r\n   * @type {number}\r\n   */\r\n  #minimumCoefficients;\r\n\r\n  /**\r\n   * Maximal coefficients that a cell can have.\r\n   * @type {number}\r\n   */\r\n  #maximalCoefficient;\r\n\r\n  /**\r\n   * Level of the game.\r\n   * @type {number}\r\n   */\r\n  #level;\r\n\r\n  /**\r\n   * All cells in the grid.\r\n   * @type {Array<Cell>}\r\n   */\r\n  #cellsArray = [];\r\n\r\n  /**\r\n   * If the grid is interrupted.\r\n   * @type {boolean}\r\n   */\r\n  #interrupted = false;\r\n\r\n  /**\r\n   * @param {number} [width=5] Width of the grid.\r\n   * @param {number} [height=5] Height of the grid.\r\n   * @param {number} [level=1] Level of the game.\r\n   * @param {number} [mines=6] Number of mines in the game. Default 5 + level.\r\n   * @param {number} [minimumCoefficients=9] Number of coefficients to be in the game. Default 8 + level.\r\n   * @param {number} [maximalCoefficient=3] Maximal coefficient of the cell.\r\n   * @throws {Error} If the parameters are invalid or inconsistents.\r\n   */\r\n  constructor ({\r\n    width = 5,\r\n    height = 5,\r\n    level = 1,\r\n    mines = Math.floor(Math.sqrt(width * height)) + level,\r\n    minimumCoefficients = 8 + level,\r\n    maximalCoefficient = 3,\r\n  } = {}) {\r\n    if (level <= 0) {\r\n      throw new Error(`The level ${level} is invalid. It should be strictly positive.`);\r\n    }\r\n    if (width <= 0) {\r\n      throw new Error(`The width ${width} is invalid. It should be strictly positive.`);\r\n    }\r\n    if (height <= 0) {\r\n      throw new Error(`The height ${height} is invalid. It should be strictly positive.`);\r\n    }\r\n    if (mines > width * height) {\r\n      throw new Error(`There are ${mines} mines for only ${width * height} cells.`);\r\n    }\r\n    if ((((width * height) - mines) * maximalCoefficient) < minimumCoefficients) {\r\n      throw new Error(`Minimum coefficient ${minimumCoefficients} cannot be reach with only ${width * height} cells, ${mines} mines and ${maximalCoefficient} maximal coefficient.`);\r\n    }\r\n    this.#width = width;\r\n    this.#height = height;\r\n    this.#mines = mines;\r\n    this.#minimumCoefficients = minimumCoefficients;\r\n    this.#maximalCoefficient = maximalCoefficient;\r\n    this.#level = level;\r\n\r\n    this.#cellsArray = this._generateGrid();\r\n  }\r\n\r\n  /**\r\n   * Total number of cells in the grid.\r\n   * @returns {number}\r\n   * @private\r\n   */\r\n  get _nbCells() {\r\n    return this.#width * this.#height;\r\n  }\r\n\r\n  /**\r\n   * Number of cells without mines.\r\n   * @returns {number}\r\n   * @private\r\n   */\r\n  get _nbNormalCells() {\r\n    return this._nbCells - this.#mines;\r\n  }\r\n\r\n  /**\r\n   * Generates the cells grid.\r\n   * @returns {Cell[]}\r\n   * @private\r\n   */\r\n  _generateGrid() {\r\n    const grid = [];\r\n    for (let i = 0; i < this.#mines; ++i) {\r\n      grid.push(new Cell({mine: true}));\r\n    }\r\n\r\n    const normalCoeffs = [];\r\n    for (let i = 0; i < this._nbNormalCells; ++i) {\r\n      normalCoeffs.push(1);\r\n    }\r\n\r\n    let total = this.#minimumCoefficients;\r\n    const normalCoeffsLength = normalCoeffs.length;\r\n    let index = 0;\r\n    let noNewCoeffs = true;\r\n    while (total >= 0) {\r\n      const currentCoeff = normalCoeffs[index];\r\n      if (currentCoeff < this.#maximalCoefficient) {\r\n        noNewCoeffs = false;\r\n        const possibleEvolution = this.#maximalCoefficient - currentCoeff;\r\n        if (_.random()) {\r\n          const evolution = _.random(1, possibleEvolution);\r\n          normalCoeffs[index] += evolution;\r\n          total -= evolution;\r\n        }\r\n      }\r\n      ++index;\r\n\r\n      if (index >= normalCoeffsLength) {\r\n        if (noNewCoeffs) {\r\n          break;\r\n        }\r\n        index %= normalCoeffsLength;\r\n        noNewCoeffs = true;\r\n      }\r\n    }\r\n    grid.push(...normalCoeffs.map(value => new Cell({value})));\r\n\r\n    return _.shuffle(grid);\r\n  }\r\n\r\n  getCell(line, column) {\r\n    return this.#cellsArray[(line * this.#width) + column];\r\n  }\r\n\r\n  getLine(line) {\r\n    return this.#cellsArray.slice(line * this.#width, ((line + 1) * this.#width))\r\n  }\r\n\r\n  getColumn(column) {\r\n    return this.#cellsArray.filter((value, index) => (index % this.#width) === column);\r\n  }\r\n\r\n  /**\r\n   * Tells how many coefficients and mines there is in a line of the grid.\r\n   * @param {Array<Cell>} line Index of the line on which we want indications.\r\n   * @returns {Indication}\r\n   */\r\n  getLineIndications(line) {\r\n    return this._getGroupIndications(this.getLine(line));\r\n  }\r\n\r\n  /**\r\n   * Tells how many coefficients and mines there is in a column of the grid.\r\n   * @param {Array<Cell>} column Index of the column on which we want indications.\r\n   * @returns {Indication}\r\n   */\r\n  getColumnIndications(column) {\r\n    return this._getGroupIndications(this.getColumn(column));\r\n  }\r\n\r\n  /**\r\n   * Tells how many coefficients and mines there is in group of cells.\r\n   * @param {Array<Cell>} group Cells on which we need to get indications\r\n   * @returns {Indication}\r\n   * @private\r\n   */\r\n  _getGroupIndications(group) {\r\n    return group.reduce(({mines, coefficients}, {mine, value}) => ({\r\n      mines: mines + ((mine) ? 1 : 0),\r\n      coefficients: coefficients + value,\r\n    }), {\r\n      mines: 0,\r\n      coefficients: 0,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Interrupts the game.\r\n   * @returns {number} The score of the game.\r\n   */\r\n  interrupt() {\r\n    this.#interrupted = true;\r\n    return this.score;\r\n  }\r\n\r\n  /**\r\n   * If the players has lost\r\n   * @return {boolean}\r\n   */\r\n  get lost() {\r\n    return this.#cellsArray.some(({mine, covered}) => (mine && !covered));\r\n  }\r\n\r\n  /**\r\n   * If player has uncovered all coefficients higher than 1, he wons.\r\n   * @return {boolean}\r\n   */\r\n  get won() {\r\n    return this.#cellsArray.every(({mine, covered, value}) => (mine || (value <= 1) || !covered));\r\n  }\r\n\r\n  /**\r\n   * Counts uncovered cells without mine.\r\n   * @return {number}\r\n   */\r\n  get nbUncoveredGoodCells() {\r\n    return this.#cellsArray.reduce((acc, elt) => acc + ((!elt.covered && !elt.mine) ? 1 : 0), 0);\r\n  }\r\n\r\n  /**\r\n   * Score of the grid. Zero if the players has lost.\r\n   * @return {number}\r\n   */\r\n  get score() {\r\n    return this.nbUncoveredGoodCells === 0 ? 0 : this.#cellsArray.reduce((acc, elt) => acc * (elt.covered ? 1 : elt.value), 1);\r\n  }\r\n\r\n  /**\r\n   * If the player interrupted the grid.\r\n   * @returns {boolean}\r\n   */\r\n  get interrupted() {\r\n    return this.#interrupted;\r\n  }\r\n\r\n  /**\r\n   * If the grid is still playing\r\n   * @returns {boolean}\r\n   */\r\n  get playing() {\r\n    return !(this.interrupted || this.lost || this.won);\r\n  }\r\n\r\n  /**\r\n   * Generate an iterator over lines.\r\n   * @returns {Generator<Cell[], void, *>}\r\n   */\r\n  *linesIterator() {\r\n    for (let index = 0; index < this.#height; ++i) {\r\n      yield this.getLine(index);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generates an iterator over columns.\r\n   * @returns {Generator<Cell[], void, *>}\r\n   */\r\n  *columnsIterator() {\r\n    for (let index = 0; index < this.#width; ++i) {\r\n      yield this.getColumn(index);\r\n    }\r\n  }\r\n};\r\n","export default class Memo {\r\n  /**\r\n   * Set used to store the memo\r\n   * @type {Set<number>}\r\n   */\r\n  #set = new Set();\r\n\r\n  /**\r\n   * Clears the memo\r\n   */\r\n  clear() {\r\n    this.#set.clear();\r\n  }\r\n\r\n  /**\r\n   * Check if value is present in the memo.\r\n   * @param {number} value\r\n   * @returns {boolean}\r\n   */\r\n  has(value) {\r\n    return this.#set.has(value);\r\n  }\r\n\r\n  /**\r\n   * Writes a number to the memo.\r\n   * @param {number} value\r\n   */\r\n  add(value) {\r\n    const numValue = +value;\r\n    if (Number.isNaN(numValue) || !Number.isSafeInteger(numValue) || numValue < 0) {\r\n      throw new Error(`The value ${value} cannot be stored by the memo.`);\r\n    }\r\n    this.#set.add(value);\r\n  }\r\n\r\n  /**\r\n   * Removes a value from the memo.\r\n   * @param {number} value\r\n   */\r\n  delete(value) {\r\n    this.#set.delete(value);\r\n  }\r\n\r\n  /**\r\n   * If the value is written in the memo, deletes it. Else, adds it.\r\n   * @param {number} value\r\n   */\r\n  toggle(value) {\r\n    if (this.has(value)) {\r\n      return this.delete(value);\r\n    } else {\r\n      return this.add(value);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generates an array from the memo\r\n   * @returns {number[]}\r\n   */\r\n  getSortedArray() {\r\n    return [...this.#set].sort((a, b) => a - b);\r\n  }\r\n}\r\n","import Grid from './Grid/Grid.js';\r\nimport Cell from './Grid/Cell.js';\r\nimport Memo from './Grid/Memo.js';\r\nimport Game from './Game/Game.js';\r\n\r\nexport { Grid, Cell, Memo, Game as VotorbFlip };\r\nexport default Game;\r\n","module.exports = require(\"lodash\");"],"sourceRoot":""}